use bip32::Language;
//use bip39::{Language, Mnemonic, Seed};

fn main() {
    use bip32::{Mnemonic, XPrv};

// Generate random Mnemonic using the default language (English)
    let mnemonic = "supply boil ethics vivid danger south day list cattle joke dwarf soon purchase boost inject combine cute neither banana lyrics awake away fire rocket"; // Mnemonic from https://iancoleman.io/bip39/
    // Caution: Mnemonics generated by LND fail to be accepted. Does LND use another checksum or something? Include Birthday? ..?

    let mnemonic = Mnemonic::new(mnemonic, Language::English);
    let mnemonic = mnemonic.unwrap();

// Derive a BIP39 seed value using the given password
    let seed = mnemonic.to_seed("password");

// Derive the root `XPrv` from the `seed` value
    let root_xprv = XPrv::new(&seed).unwrap();
    assert_eq!(root_xprv, XPrv::derive_from_path(&seed, &"m".parse().unwrap()).unwrap());

// Derive a child `XPrv` using the provided BIP32 derivation path
    let child_path = "m/0'";
    let child_xprv = XPrv::derive_from_path(&seed, &child_path.parse().unwrap()).unwrap();

// Get the `XPub` associated with `child_xprv`.
    let child_xpub = child_xprv.public_key();

// Get the ECDSA/secp256k1 signing and verification keys for the xprv and xpub
    let signing_key = child_xprv.private_key();
    let verification_key = child_xpub.public_key();

    // Sign and verify an example message using the derived keys.
    use bip32::secp256k1::ecdsa::{
        signature::{Signer, Verifier},
        Signature
    };

    let example_msg = b"REKT";
    let signature: Signature = signing_key.sign(example_msg);

    println!("{:?}", signature);

    let some_magic_byte_that_i_dont_understand = 31; // I reverse-engineered this. WTF is it all about?

    // todo extract the bytes from the variable signature instead of using dummy data
    let x: [u8; 65] = [some_magic_byte_that_i_dont_understand, 74, 156, 141, 188, 77, 218, 194, 157, 74, 7, 53, 149, 51, 159, 156, 97, 33, 160, 41, 247, 115, 171, 162, 62, 1, 68, 6, 26, 169, 72, 209, 198, 42, 142, 11, 185, 199, 238, 118, 114, 41, 68, 59, 28, 20, 56, 69, 164, 114, 178, 138, 167, 160, 244, 145, 79, 89, 202, 208, 240, 40, 20, 216, 32];

    let sig_zbase = zbase32::encode(&x, 65 * 8);

    println!("{:?}", sig_zbase);

    assert!(verification_key.verify(example_msg, &signature).is_ok());
}
